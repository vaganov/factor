.TH factor 3 "22 Mar. 2012"
.SH NAME
\fBfactor\fR \- factor integer into prime degrees
.SH SYNOPSIS
\fB#include <factor.h>
.P
\fBuint32_t factor (uint64_t \fIn\fB, struct degree* \fId\fB, uint64_t* \fIr\fB);
.SH DESCRIPTION
\fBfactor()\fR factors integer \fIn\fR into product of prime degrees; these prime degrees are stored in array \fId \fRof \fBstruct degree\fR, which consists of prime number \fIp\fR and integer degree \fIb\fR; prime degrees in \fId\fR are sorted by \fIp\fR; besides, \fIn\fR can have \fBthe only\fR prime divisor greater than \fB2^32\fR; if \fIn\fR has one, its value is stored in \fB*\fIr\fR, otherwise \fB*\fIr\fR is set to \fB1\fR; for \fIn\fB = 0 *\fIr\fR is set to \fB0\fR; also \fIr\fR can be set to \fB0\fR
.SH ALGORITHM
no smart algorithm is used because of small input (\fIn\fB < 2^64\fR); initially \fIn\fR is checked to divide by small prime numbers - \fB2\fR, \fB3\fR, \fB5\fR and \fB7\fR; then all numbers, coprime to \fB210 = 2 * 3 * 5 * 7\fR, split into \fB48 = (2 - 1) * (3 - 1) * (5 - 1) * (7 - 1)\fR arithmetic progressions modulo \fB210\fR; \fIn\fR is checked to divide by all the numbers sequentially - in separate (POSIX) thread for each progression
.SH RETURN VALUE
total number of prime degrees stored in \fId\fR is returned; this number does not exceed \fB15\fR for \fIn\fB < 2^64\fR and \fB9\fR for \fIn\fB < 2^32
.SH SEE ALSO
\fBfactor\fR(1)
.SH AUTHOR
Nikita Vaganov
